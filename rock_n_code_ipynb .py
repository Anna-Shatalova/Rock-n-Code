# -*- coding: utf-8 -*-
"""ROCK-N-CODE.ipynb""

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FVVl6jTAfyienraEk6BFMhmsx8EQ1rKV

# Music genre prediction

**Описание задачи**

Вы сотрудник Отдела Data Science популярного музыкального стримингового сервиса. Сервис расширяет работу с новыми артистами и музыкантами, в связи с чем возникла задача -- правильно классифицировать новые музыкальные треки, чтобы улучшить работу рекомендательной системы. Ваши коллеги из отдела работы со звуком подготовили датасет, в котором собраны некоторые характеристики музыкальных произведений и их жанры. Ваша задача - разработать модель, позволяющую классифицировать музыкальные произведения по жанрам.

В ходе работы пройдите все основные этапы полноценного исследования:

*  загрузка и ознакомление с данными
*  предварительная обработка
*  полноценный разведочный анализ
*  разработка новых синтетических признаков
*  проверка на мультиколлинеарность
*  отбор финального набора обучающих признаков
*  выбор и обучение моделей
*  итоговая оценка качества предсказания лучшей модели
*  анализ важности ее признаков

**ВАЖНО**  
Необходимо реализовать решение с использованием технологии `pipeline` (из библиотеки `sklearn`)

**ОЖИДАЕМЫЙ РЕЗУЛЬТАТ**

* Оформленный репозиторий на GitHub (ноутбук с исследованием + код приложения)
* Развернутое web-приложение (с использованием библиотеки Streamlit)

## ✅ Участники проекта, репозиторий, приложение

Команда:
1. Шаталова Анна;
2. Скрябин Евгений;
3. Дёмин Евгений.

GitHub:

Приложение:

## ✅ Импорт библиотек, установка констант
"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# !pip install catboost -q

import pandas as pd
import numpy as np

#Скрябин Евгений
from matplotlib import pyplot as plt # для постраения графиков
import seaborn as sns # для постраения графиков

from sklearn.model_selection import train_test_split
from sklearn.metrics import f1_score
from catboost import CatBoostClassifier

RANDOM_STATE = 42
TEST_SIZE = 0.25

"""## ✅ Загрузка и обзор данных"""

TRAIN = "https://www.dropbox.com/scl/fi/5zy935lqpaqr9lat76ung/music_genre_train.csv?rlkey=ccovu9ml8pfi9whk1ba26zdda&dl=1"
TEST = "https://www.dropbox.com/scl/fi/o6mvsowpp9r3k2lejuegt/music_genre_test.csv?rlkey=ac14ydue0rzlh880jwj3ebum4&dl=1"

"""**Описание полей данных**

`instance_id` - уникальный идентификатор трека  
`track_name` - название трека  
`acousticness` - акустичность  
`danceability` - танцевальность  
`duration_ms` -продолжительность в милисекундах  
`energy` - энергичность  
`instrumentalness` - инструментальность  
`key` - тональность  
`liveness` - привлекательность  
`loudness` - громкость  
`mode` - наклонение  
`speechiness` - выразительность  
`tempo` - темп  
`obtained_date` - дата загрузки в сервис  
`valence` - привлекательность произведения для пользователей сервиса  
`music_genre` - музыкальный жанр

### data frame 'train'
"""

train = pd.read_csv(TRAIN)

train.sample(5) # обзор пяти случайных строк

train.head().T # обзор данных

train.info() # обзор данных

desc_features = train.isnull().sum() # проверка - отсутствующие данные
print(desc_features[desc_features > 0])
(desc_features[desc_features > 0] / train.shape[0]) * 100 # пропуски в процентах

#ED
train.shape # определим размер датафрейма

#ED
train.isnull().sum() # посчитаем пропуски в столбцах

#ED
(train.isnull().sum() / train.shape[0]) * 100 # определим процентное отноешение пропусков
                                              # ко всем строкам датафрейма

#ED
train.describe().loc[['min', 'max']].T # найдём деапазон значений в столбцах

#ED
# проверим датафрейм на наличие дубликатов
train[train.duplicated()]

# исследование уникальных значений категориальных признаков

cols = train.dtypes[train.dtypes == 'object'].index

for col in cols:
    unq = train[col].unique()
    print(f'{col} - {unq}\n')

train.track_name

"""### data frame 'test'"""

test = pd.read_csv(TEST)

#ED
test.sample(5) # обзор пяти случайных строк

test.head().T # обзор данных

#ED
test.info() # обзор данных

#ED
test.shape # определим размер датафрейма

#ED
test.isnull().sum() # посчитаем пропуски в столбцах

#ED
(test.isnull().sum() / test.shape[0]) * 100 # определим процентное отноешение пропусков
                                              # ко всем строкам датафрейма

test.describe().loc[['min', 'max']].T # найдём деапазон значений в столбцах

#ED
# проверим датафрейм на наличие дубликатов
test[test.duplicated()]

# исследование уникальных значений категориальных признаков

cols = test.dtypes[test.dtypes == 'object'].index

for col in cols:
    unq = test[col].unique()
    print(f'{col} - {unq}\n')

"""### выводы:

*   ✅ названия описательных признаков не требуют исправлений и приведения к единообразному формату

* train = `instance_id` - изменить формат float64 -> int64
* train + test = `obtained_date` - перевести к формату datetime


* в столбцах датайфрейма 'train' имеются пропуски:
    1. `key`   - 735 (3.60 %)
    2. `mode`  - 506 (2.48 %)
    3. `tempo` - 442 (2.17 %)
* в столбцах датайфрейма 'train' имеются пропуски:
    1. `key`   - 158 (3.10 %)
    2. `mode`  - 149 (2.92 %)
    3. `tempo` - 121 (2.37 %)

* train + test = `duration_ms` и `loudness` - имеются отрицательные значения

* ✅дубликаты в датафреймах отсутствуют

*   ✅train = `track name`, `mode`, `music_genre` - привести данные к нижнему регистру и пробелы заменить на  нижние подчеркивание
*   test = `track name`, `mode` - привести данные к нижнему регистру и пробелы заменить на  нижние подчеркивание
*   ?? train = `track name` - ❗ решить, что делать с "(feat. MC Spyder)",  "- Digital Single" и пр.
*   ?? ✅train = `key` - убрать символ решетки #

❗**Вопрос**, почему dataframe разбит на обучающую и проверочную выборку, а не на обучающую, проверочную и тестовую ⁉

## ✅ Предварительная обработка данных

### Скрябин Евгений
"""

train.music_genre = train.music_genre.str.lower().str.replace(' ', '_')
#train.mode = train.mode.str.lower().str.replace(' ', '_') # нужно убрать пропуски

train.key.str.replace('#', '') # очистка значений признака key от #

"""### Условные обозначения:

- `имена` переменных
- `имена` переменных

1) Проверить на пропуски

2) взять размер датасета

3) проверить типы данных

4) есть ли выбросы

5) привести написание к одному регистру

6) дату привести к удобному типу данных

7) задать округление
"""

#

"""## ✅ Разведочный анализ

ИДЕЯ: У меня есть идея проанализировать по названиям песен. Может ты возьмешь на себя работу с title - привести к нижнему реестру, проверить повторы, какие слова чаще всего встречаются, есть ли зависимость повторяемости слов по жанрам (ну, например, в жанре хэви металл чаще всего встречается "смерть, кровь" - это так навскидку))
"""



"""## ✅ Работа с признаками"""



"""## ❌ Выбор и обучение моделей"""





"""## ❌ Оценка качества"""





"""## ❌ Анализ важности признаков модели"""



